#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jun  2 10:02:06 2020

@author: Fanny Fredriksson and Karen Marie Sand√∏ Ambrosen
"""

import numpy as np
import os.path as op
import dyconnmap
import pickle
from os import listdir
from datetime import datetime
from tqdm import tqdm #count for loops
import matplotlib.pyplot as plt
from os import mkdir
import pandas as pd
import pdb
from dyconnmap.analytic_signal import analytic_signal
from scipy.stats import ttest_ind
from statsmodels.stats.multitest import multipletests
import statsmodels.api as sm
import scipy
from mne import read_labels_from_annot
from mne.datasets import fetch_fsaverage
from collections import OrderedDict
from pprint import pprint

#%%################################
# Plot mean timeseries across subjects
###################################

# Load timeseries (label_ts)
atlas = 'BAita_timeseries_2005/' #'DK_timeseries_0505/'
dir_ts = '/share/FannyMaster/PythonNew/'+atlas+'Subjects_ts/'

mean_ts = []
max_ts = []
min_ts = []

label_ts = []
for file in tqdm(listdir(dir_ts)):
    with open(dir_ts+file, 'rb') as file:
        label_dict = pickle.load(file)
    #print(label_ts)
    label_ts.append(np.array(list(label_dict['timeseries']))[:,0:10000])
   
#mean and standard deviation across subjects
mean_ts = np.mean(label_ts,axis=0)
sd_ts = np.std(label_ts,axis=0)       

# Plot timeseries
plt.figure()
tp = None
n_ch = 5
for c, i in enumerate(range(n_ch)): #range(len(mean_ts)):
    plt.subplot(n_ch,1,c+1)
    if tp == None:    
        plt.plot(mean_ts[i]+sd_ts[i])
        plt.plot(mean_ts[i])
        plt.plot(mean_ts[i]-sd_ts[i])
    else:
        plt.plot(mean_ts[i][0:tp]+sd_ts[i][0:tp])
        plt.plot(mean_ts[i][0:tp])
        plt.plot(mean_ts[i][0:tp]-sd_ts[i][0:tp])

plt.figure()
plt.plot(mean_ts.T+sd_ts.T)
plt.plot(mean_ts.T)
plt.plot(mean_ts.T-sd_ts.T)

tp = 250
plt.figure()
plt.plot(mean_ts.T[0:tp]+sd_ts.T[0:tp])
plt.plot(mean_ts.T[0:tp])
plt.plot(mean_ts.T[0:tp]-sd_ts.T[0:tp])

#%%###########################################################################
# Function to load connectivity matrices
##############################################################################

from makeClassification import getData, getEgillX, BAitaSig, getBAitaSigX

from utilsResults import getLabels, getConMatrices, band_idx
    


##############################################################################
def significant_connected_areas(pval_idx, labels, n_BAitaSig=None):
    """
    Parameters
    ----------
    dir_nz_coef_idx : string
        Path to the wanted non-zero coefficients indices. 
    min_fraction : float
        The minimum fraction of times a feature have been used.
    labels : list
        A containig strings with names of brain areas, generated by 
        get*Labels().
    wanted_info : string
        Can be 'all', 'bands' or 'both'. 
    clf_types : list of strings
        Each string corresponds to the name of a classifier.
        
    Returns
    -------
    connected_areas : string
        String containing the most connected areas and what band that is used.

    Notes
    -------
    Prints the areas that are connected more then the minimum fraction of 
    times.

    """
    # Used frequency bands 
    freq_bands = ["delta", "theta", "alpha", "beta1", "beta2", "gamma"]
    # Initialize dictionary to return
    connected_areas = OrderedDict()
   
    # Get indices of triangular matrix
    x, y = np.triu_indices(len(labels),k=1)  
    
    # Number of elements for each frequency band 
    n_feature_bands = int(((len(labels))*(len(labels)-1))/2)
        
    # Get band number and real index
    band_index = [band_idx(idx, n_feature_bands, n_BAitaSig) for idx in pval_idx[0]]
        
        
    if n_BAitaSig == None:
        #Print names of most connected brain areas
        con_area = [[freq_bands[i[0]], labels[x[i[1]]], labels[y[i[1]]]] for i in band_index]
        connected_areas['all'] = con_area
    else:
        #Print names of most connected brain areas
        con_area = [[freq_bands[i[0]], labels[i[0]][i[1]]] for i in band_index]
        connected_areas['all'] = con_area
            
    return connected_areas

    
#%%##################################################
# T-test of all roi-roi connections 
#####################################################

test = 'ttest' #'MannWhitneyU'

# atlas = ['DK_timeseries_0505', 'DKEgill_timeseries_2705', 'BAita_timeseries_2005', 'BAitaSig_timeseries_2705']
# atlas2 = ['Desikan-Killiany', 'Desikan-Killiany selected rois (Egill)', 'Brodmann', 'Brodmann selected rois (Lorenzo et al.)']
# atlas3 = ['DK', 'DKEgill', 'BAita', 'BAitaSig']
# con_type = ['plv', 'pli', 'lps']


atlas = ['BAita_timeseries_2005', 'BAitaSig_timeseries_2705', 'DKEgill_timeseries_2705'] # , 'DK_timeseries_0505']
atlas2 = ['Brodmann', 'Brodmann selected rois (Lorenzo et al.)', 'Desikan-Killiany selected rois (Egill)'] #, 'Desikan-Killiany']
atlas3 = ['BAita', 'BAitaSig', 'DKEgill'] #, 'DK']
#atlas3 = ['DK', 'DKEgill', 'BAita', 'BAitaSig']
con_type = ['pli']

dir_y_ID = '/share/FannyMaster/PythonNew/Age_Gender.csv'

partialDat = True

for parc in range(len(atlas)):
    dir_features = '/share/FannyMaster/PythonNew/' + atlas[parc] + '/DiLorenzo/Features/'
    print('------------------------------------')
    print(atlas2[parc])
    print('------------------------------------')
    
    if atlas3[parc] == 'BAitaSig':
        labels, n_BAitaSig = getLabels(atlas3[parc])
    else:
        labels = getLabels(atlas3[parc])
        n_BAitaSig = None
        
    for con in range(len(con_type)):
        
        if atlas[parc]=='DK_timeseries_0505' and con_type[con]=='lps':
            continue
            
        print(con_type[con])
        
        X, y = getData(dir_features, dir_y_ID, con_type[con], partialData = partialDat)

        if atlas[parc] == 'DKEgill_timeseries_2705':
            X = getEgillX(X)        
        elif atlas[parc] == 'BAitaSig_timeseries_2705':
            X, _ = getBAitaSigX(X)

        hc = X[y==1]
        sz = X[y==0]
        
        if test == 'MannWhitneyU':
            pval = []
            for i in range(len(hc[0])):
                stats, pval_tmp = scipy.stats.mannwhitneyu(hc[:,i],sz[:,i])
                pval.append(pval_tmp)
            pval = np.array(pval)
            
        elif test == 'ttest':
            #hc = np.log(hc)
            #sz = np.log(sz)
            stats, pval = ttest_ind(hc,sz,axis=0,equal_var=False)
            
        elif test == 'logF':
            F = np.var(hc[:,i])/np.var(sz[:,i])
            p = scipy.stats.f.sf(stats**2,len(hc[:,i])-1,len(sz[:,i])-1)
        
        print('Number of significant connections:                 ', sum(pval<0.05), ', Minimum p-value:', np.min(pval))
        print('Number of significant connections after Bonferroni:', sum(pval<0.05/len(hc[0])), ', Minimum corrected p-value:', np.min(pval*len(hc[0])))
        
        reject, pval_cor, alphacSidak, alphacBonf = multipletests(pval,alpha=0.05, method='fdr_bh')
        #print('Number of significant connections after FDR (BH):', sum(pval_cor<0.05), ', Minimum corrected p-value:', np.min(pval_cor))
        
        pval_bonf = pval*len(hc[0])
        pval_idx = np.nonzero(pval_bonf<0.05)
        
        #connections = most_connected_areas(pval_idx, min_fraction, labels, wanted_info, clf_types, n_BAitaSig=None)
        connections = significant_connected_areas(pval_idx, labels, n_BAitaSig)
        pprint(connections)
        
        mu_con_sig = {'avg. HC': np.mean(hc[:,pval_idx],axis=0), 'avg. SZ': np.mean(sz[:,pval_idx],axis=0)}
        pprint(mu_con_sig)
        
        # pval_bh = pval_cor
        # pval_idx = np.nonzero(pval_bh<0.05)
        
        # #connections = most_connected_areas(pval_idx, min_fraction, labels, wanted_info, clf_types, n_BAitaSig=None)
        # connections = significant_connected_areas(pval_idx, labels, n_BAitaSig)
        # pprint(connections)
